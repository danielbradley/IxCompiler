
.. AST

~!include/ixcompiler.AST.h~
#ifndef IXCOMPILER_AST_H
#define IXCOMPILER_AST_H

#include "ixcompiler.h"

AST*        AST_new             ( Tokenizer** tokenizer );
AST*        AST_free            ( AST**       self );
const Tree* AST_getTree         ( const AST*  self );
const File* AST_getTokenizerFile( const AST*  self );

#endif
~

~!c/ixcompiler.AST.c~
#include "ixcompiler.h"
#include "ixcompiler.AST.h"
#include "ixcompiler.EnumTokenGroup.h"
#include "ixcompiler.EnumTokenType.h"
#include "ixcompiler.IxParser.h"
#include "ixcompiler.Node.h"
#include "ixcompiler.Platform.h"
#include "ixcompiler.Token.h"
#include "ixcompiler.TokenGroup.h"
#include "ixcompiler.Tokenizer.h"
#include "ixcompiler.Tree.h"

struct _AST
{
    Tokenizer* tokenizer;
    Tree* tree;
};

static void Parse          ( AST* self );

static void ParseRoot      ( Node* parent, Tokenizer* tokenizer );
static void ParseComplex   ( Node* parent, Tokenizer* tokenizer );
static void ParseClass     ( Node* parent, Tokenizer* tokenizer );
static void ParseMethod    ( Node* parent, Tokenizer* tokenizer );
static void ParseStatement ( Node* parent, Tokenizer* tokenizer, bool one_liner );
static void ParseBlock     ( Node* parent, Tokenizer* tokenizer );
static void ParseExpression( Node* parent, Tokenizer* tokenizer );
~

~c/ixcompiler.AST.c~
AST* AST_new( Tokenizer** tokenizer )
{
    AST* self = Platform_Alloc( sizeof( AST ) );
    if ( self )
    {
        self->tokenizer = *tokenizer; *tokenizer = null;
        self->tree      = Tree_new();
    }

    Parse( self );

    return self;
}
~

~c/ixcompiler.AST.c~
AST* AST_free( AST** self )
{
    if ( *self )
    {
        Tree_free( &(*self)->tree );
    }
    Platform_Free( self );

    return *self;
}
~

~c/ixcompiler.AST.c~
const Tree* AST_getTree( const AST* self )
{
    return self->tree;
}
~

~c/ixcompiler.AST.c~
const File* AST_getTokenizerFile( const AST* self )
{
    return Tokenizer_getFile( self->tokenizer );
}
~

~c/ixcompiler.AST.c~
static void Parse( AST* self )
{
    Token* t    = null;
    Node*  root = Node_new( &t );
    ParseRoot( root, self->tokenizer );
    Tree_setRoot( self->tree, &root );
}
~

~c/ixcompiler.AST.c~
static void ParseRoot( Node* parent, Tokenizer* tokenizer )
{
    while ( Tokenizer_hasMoreTokens( tokenizer ) )
    {
        Token*         token       = Tokenizer_nextToken( tokenizer );
        EnumTokenGroup token_group = TokenGroup_getGroupType( Token_getTokenGroup( token ) );
        EnumTokenType  token_type  = Token_getTokenType( token );

        Node_addChild( parent, &token );

        if ( token_group == ALPHANUMERIC )
        {
            Node* last = null;

            switch ( token_type )
            {
            case COPYRIGHT:
                last = Node_getLastChild( parent );
                Node_setTag( last, "copyright" );
                ParseStatement( last, tokenizer, TRUE );
                break;

            case LICENSE:
                last = Node_getLastChild( parent );
                Node_setTag( last, "license" );
                ParseStatement( last, tokenizer, TRUE );
                break;

            case MODIFIER:
                ParseComplex( Node_getLastChild( parent ), tokenizer );
                break;

            default:
                continue;
            }
        }
    }
}
~

~c/ixcompiler.AST.c~
static void ParseComplex( Node* parent, Tokenizer* tokenizer )
{
    while ( Tokenizer_hasMoreTokens( tokenizer ) )
    {
        Token*         token       = Tokenizer_nextToken( tokenizer );
        EnumTokenGroup token_group = TokenGroup_getGroupType( Token_getTokenGroup( token ) );
        EnumTokenType  token_type  = Token_getTokenType( token );
        const char*    content     = Token_getContent( token );
        int            ch          = content[0];

        Node_addChild( parent, &token );

        if ( (token_group == CLOSE)        && (token_type == ENDBLOCK) ) break;
        else
        if ( (token_group == ALPHANUMERIC) && (token_type == CLASS) )
        {
            Node_setTag( parent, "class" );
            ParseClass( Node_getLastChild( parent ), tokenizer );
            break;
        }
        else
        if ( (token_group == ALPHANUMERIC) && (token_type == WORD) )
        {
            Node_setTag( parent, "method" );
            ParseMethod( Node_getLastChild( parent ), tokenizer );
            break;
        }
        else
        if ( (token_group == OPEN)         && (token_type == STARTBLOCK) )
        {
            ParseBlock( Node_getLastChild( parent ), tokenizer );
            break;
        }
        else
        {
            continue;
        }
    }
}
~

~c/ixcompiler.AST.c~
static void ParseClass( Node* parent, Tokenizer* tokenizer )
{
    while ( Tokenizer_hasMoreTokens( tokenizer ) )
    {
        Token*         token       = Tokenizer_nextToken( tokenizer );
        EnumTokenGroup token_group = TokenGroup_getGroupType( Token_getTokenGroup( token ) );
        EnumTokenType  token_type  = Token_getTokenType( token );
        const char*    content     = Token_getContent( token );
        int            ch          = content[0];

        Node_addChild( parent, &token );

        if ( (token_group == CLOSE)        && (token_type == ENDBLOCK) ) break;
        else
        if ( (token_group == OPEN) && (token_type == STARTBLOCK) )
        {
            ParseBlock( Node_getLastChild( parent ), tokenizer );
            break;
        }
        else
        {
            continue;
        }
    }
}
~

~c/ixcompiler.AST.c~
static void ParseMethod( Node* parent, Tokenizer* tokenizer )
{
    while ( Tokenizer_hasMoreTokens( tokenizer ) )
    {
        Token*         token       = Tokenizer_nextToken( tokenizer );
        EnumTokenGroup token_group = TokenGroup_getGroupType( Token_getTokenGroup( token ) );
        EnumTokenType  token_type  = Token_getTokenType( token );
        const char*    content     = Token_getContent( token );
        int            ch          = content[0];

        Node_addChild( parent, &token );

        if ( (token_group == CLOSE)        && (token_type == ENDBLOCK) ) break;
        else
        if ( (token_group == OPEN) && (token_type == STARTEXPRESSION) )
        {
            ParseExpression( Node_getLastChild( parent ), tokenizer );
        }
        else
        if ( (token_group == OPEN) && (token_type == STARTBLOCK) )
        {
            ParseBlock( Node_getLastChild( parent ), tokenizer );
            break;
        }
        else
        {
            continue;
        }
    }
}
~

~c/ixcompiler.AST.c~
static void ParseStatement( Node* parent, Tokenizer* tokenizer, bool one_liner )
{
    while ( Tokenizer_hasMoreTokens( tokenizer ) )
    {
        Token*         token       = Tokenizer_nextToken( tokenizer );
        EnumTokenGroup token_group = TokenGroup_getGroupType( Token_getTokenGroup( token ) );
        EnumTokenType  token_type  = Token_getTokenType( token );

        Node_addChild( parent, &token );

        if ( token_type == STOP )
        {
            break;
        }
        else
        if ( one_liner && (token_type == NEWLINE) )
        {
            break;
        }
        else
        if ( (token_group == OPEN) && (token_type == STARTEXPRESSION) )
        {
            ParseExpression( Node_getLastChild( parent ), tokenizer );
        }
        else
        if ( (token_group == OPEN) && (token_type == STARTBLOCK) )
        {
            ParseBlock( Node_getLastChild( parent ), tokenizer );
            break;
        }
    }
}
~

~c/ixcompiler.AST.c~
static void ParseBlock( Node* parent, Tokenizer* tokenizer )
{
    while ( Tokenizer_hasMoreTokens( tokenizer ) )
    {
        Token*         token       = Tokenizer_nextToken( tokenizer );
        EnumTokenGroup token_group = TokenGroup_getGroupType( Token_getTokenGroup( token ) );
        EnumTokenType  token_type  = Token_getTokenType( token );
        const char*    content     = Token_getContent( token );
        int            ch          = content[0];

        Node_addChild( parent, &token );

        if ( (token_group == CLOSE)    && (token_type == ENDBLOCK) ) break;
        else
        if ( (token_group == SYMBOLIC) && ((token_type == SYMBOL) || (token_type == INFIXOP)) )
        {
            switch ( ch )
            {
            case '@':
            case '%':
                ParseStatement( Node_getLastChild( parent ), tokenizer, TRUE );
                break;
            }
        }
        else
        if ( (token_group == ALPHANUMERIC) && (token_type == KEYWORD) )
        {
            ParseStatement( Node_getLastChild( parent ), tokenizer, FALSE );
        }
        else
        if ( (token_group == ALPHANUMERIC) )
        {
            ParseStatement( Node_getLastChild( parent ), tokenizer, FALSE );
        }
    }
}
~

~c/ixcompiler.AST.c~
static void ParseExpression( Node* parent, Tokenizer* tokenizer )
{
    while ( Tokenizer_hasMoreTokens( tokenizer ) )
    {
        Token*         token       = Tokenizer_nextToken( tokenizer );
        EnumTokenGroup token_group = TokenGroup_getGroupType( Token_getTokenGroup( token ) );
        EnumTokenType  token_type  = Token_getTokenType( token );
        const char*    content     = Token_getContent( token );
        int            ch          = content[0];

        Node_addChild( parent, &token );

        if ( (token_group == CLOSE)    && (token_type == ENDEXPRESSION) ) break;
        else
        if ( (token_group == OPEN) && (token_type == STARTEXPRESSION) )
        {
            ParseExpression( Node_getLastChild( parent ), tokenizer );
        }
        else
        {
            continue;
        }
    }
}
~
