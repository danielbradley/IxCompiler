
.. NodeIterator

~!include/ixcompiler.NodeIterator.h~
#ifndef IXCOMPILER_NODEITERATOR_H
#define IXCOMPILER_NODEITERATOR_H

#include "ixcompiler.h"
#include "ixcompiler.EnumTokenType.h"

NodeIterator* NodeIterator_new                   ( const Array*  nodes );
NodeIterator* NodeIterator_free                  ( NodeIterator** self );
bool          NodeIterator_hasNext               ( NodeIterator*  self );
bool          NodeIterator_hasNonWhitespace      ( NodeIterator*  self );
bool          NodeIterator_hasNonWhitespaceOfType( NodeIterator*  self, EnumTokenType type );
const Node*   NodeIterator_next                  ( NodeIterator*  self );
const Node*   NodeIterator_peek                  ( NodeIterator*  self );

#endif
~

~!c/ixcompiler.NodeIterator.c~
#include "ixcompiler.h"
#include "ixcompiler.Array.h"
#include "ixcompiler.EnumTokenType.h"
#include "ixcompiler.EnumTokenGroup.h"
#include "ixcompiler.Node.h"
#include "ixcompiler.NodeIterator.h"
#include "ixcompiler.Platform.h"
#include "ixcompiler.Token.h"
#include "ixcompiler.TokenGroup.h"

struct _NodeIterator
{
    const Array* nodes;
    int          next;
};
~

~c/ixcompiler.NodeIterator.c~
NodeIterator* NodeIterator_new( const Array* nodes )
{
    NodeIterator* self = Platform_Alloc( sizeof( NodeIterator ) );
    if ( self )
    {
        self->nodes = nodes;
        self->next  = 0;
    }
    return self;
}
~

~c/ixcompiler.NodeIterator.c~
NodeIterator* NodeIterator_free( NodeIterator** self )
{
    if ( *self )
    {
        (*self)->nodes = null;
        (*self)->next  = 0;

        Platform_Free( self );
    }
    return *self;
}
~

~c/ixcompiler.NodeIterator.c~
bool NodeIterator_hasNext( NodeIterator* self )
{
    return (self->next < Array_getLength( self->nodes ));
}
~

~c/ixcompiler.NodeIterator.c~
bool NodeIterator_hasNonWhitespace( NodeIterator* self )
{
    bool has_next_nws = FALSE;

    while ( NodeIterator_hasNext( self ) )
    {
        const Node*   node  = Array_getObject( self->nodes, self->next );
        const Token*  token = Node_getToken( node );
        EnumTokenType type  = Token_getTokenType( token );

        if ( LINECOMMENT == type )
        {
            while ( NodeIterator_hasNext( self ) )
            {
                const Token* token = Node_getToken( NodeIterator_next( self ) );

                if ( Token_getTokenType( token ) == NEWLINE )
                {
                    break;
                }
            }
        }
        else
        if ( WHITESPACE != TokenGroup_getGroupType( Token_getTokenGroup( token ) ) )
        {
            has_next_nws = TRUE;
            break;
        }
        else
        {
            NodeIterator_next( self );
        }
    }

    return has_next_nws;
}
~

~c/ixcompiler.NodeIterator.c~
bool NodeIterator_hasNonWhitespaceOfType( NodeIterator* self, EnumTokenType type )
{
    bool has = FALSE;

    if ( NodeIterator_hasNonWhitespace( self ) )
    {
        const Node* peek = NodeIterator_peek( self );
        has = (type == Token_getTokenType( Node_getToken( peek ) ) );
    }
    return has;
}
~

~c/ixcompiler.NodeIterator.c~
const Node* NodeIterator_next( NodeIterator* self )
{
    return (const void*) Array_getObject( self->nodes, self->next++ );
}
~

~c/ixcompiler.NodeIterator.c~
const Node* NodeIterator_peek( NodeIterator* self )
{
    return (const void*) Array_getObject( self->nodes, self->next );
}
~
