
.. Ix Source Expression

An expression evaluates to a result.
For example the expression 1 + 1 evaluates to 2.
In programming languages,
expressions can also involve the invocation of functions
and the results of the functions can be passed to functions.
For example,

~
div( max( c ) + max( d ), 2 )
~

As an ?expression tree?

~
div()
    +
    max()
        c
    max()
        c
~

~!include/ixcompiler.IxSourceExpression.h~
#ifndef IXCOMPILER_IXSOURCEEXPRESSION_H
#define IXCOMPILER_IXSOURCEEXPRESSION_H

#include "ix.h"
#include "ixcompiler.h"

IxSourceExpression* IxSourceExpression_new( const Node* firstNode );

IxSourceExpression*       IxSourceExpression_free              (       IxSourceExpression** self );
bool                      IxSourceExpression_isValue           ( const IxSourceExpression*  self );
bool                      IxSourceExpression_hasPrefixOperator ( const IxSourceExpression*  self );
bool                      IxSourceExpression_hasInfixOperator  ( const IxSourceExpression*  self );
bool                      IxSourceExpression_hasPostfixOperator( const IxSourceExpression*  self );
const String*             IxSourceExpression_getValue          ( const IxSourceExpression*  self );
const String*             IxSourceExpression_getPrefixOperator ( const IxSourceExpression*  self );
const IxSourceExpression* IxSourceExpression_getLeftExpression ( const IxSourceExpression*  self );
const String*             IxSourceExpression_getInfixOperator  ( const IxSourceExpression*  self );
const IxSourceExpression* IxSourceExpression_getRightExpression( const IxSourceExpression*  self );
const String*             IxSourceExpression_getPostfixOperator( const IxSourceExpression*  self );

#endif
~

~!c/ixcompiler.IxExpression.c~
#include "ixcompiler.IxSourceExpression.h"
#include "ixcompiler.Token.h"

struct _IxSourceExpression
{
    bool                     invalid;
    bool                     isValue;
    String*                  value;
    String*                  prefixOperator;
    IxSourceExpression*      leftExpression;
    String*                  infixOperator;
    IxSourceExpression*      rightExpression;
    String*                  postfixOperator;
};

void IxSourceExpression_parse( IxSourceExpression* self, const Node* firstNode );
~

~c/ixcompiler.IxExpression.c~
IxSourceExpression* IxSourceExpression_new( const Node* firstNode )
{
    IxSourceExpression* self = Platform_Alloc( sizeof(IxSourceExpression) );
    {
        IxSourceExpression_parse( self, firstNode );
    }
    return self;
}
~

~c/ixcompiler.IxExpression.c~
IxSourceExpression* IxSourceExpression_free( IxSourceExpression** self )
{
    if ( *self )
    {
        String_free            ( &(*self)->value           );
        String_free            ( &(*self)->prefixOperator  );
        String_free            ( &(*self)->infixOperator   );
        String_free            ( &(*self)->postfixOperator );
        IxSourceExpression_free( &(*self)->leftExpression  );
        IxSourceExpression_free( &(*self)->rightExpression );

        Platform_Free( self );
    }
    return *self;
}
~

~c/ixcompiler.IxExpression.c~
bool IxSourceExpression_isValue( const IxSourceExpression* self )
{
    return (null != self->value);
}
~

~c/ixcompiler.IxExpression.c~
bool IxSourceExpression_hasPrefixOperator( const IxSourceExpression* self )
{
    return (null != self->prefixOperator);
}
~
~c/ixcompiler.IxExpression.c~
bool IxSourceExpression_hasInfixOperator( const IxSourceExpression* self )
{
    return (null != self->infixOperator);
}

~c/ixcompiler.IxExpression.c~
bool IxSourceExpression_hasPostfixOperator( const IxSourceExpression* self )
{
    return (null != self->postfixOperator);
}
~

~c/ixcompiler.IxExpression.c~
const String* IxSourceExpression_getValue( const IxSourceExpression* self )
{
    return self->value;
}
~

~c/ixcompiler.IxExpression.c~
const String* IxSourceExpression_getPrefixOperator( const IxSourceExpression* self )
{
    return self->prefixOperator;
}
~

~c/ixcompiler.IxExpression.c~
const IxSourceExpression* IxSourceExpression_getLeftExpression( const IxSourceExpression* self )
{
    return self->leftExpression;
}
~

~c/ixcompiler.IxExpression.c~
const String* IxSourceExpression_getInfixOperator( const IxSourceExpression* self )
{
    return self->infixOperator;
}
~

~c/ixcompiler.IxExpression.c~
const IxSourceExpression* IxSourceExpression_getRightExpression( const IxSourceExpression* self )
{
    return self->rightExpression;
}
~

~c/ixcompiler.IxExpression.c~
const String* IxSourceExpression_getPostfixOperator( const IxSourceExpression* self )
{
    return self->postfixOperator;
}
~

~c/ixcompiler.IxExpression.c~
void IxSourceExpression_parse( IxSourceExpression* self, const Node* firstNode )
{

    
}
~

    NodeIterator* it = Node_iterator( firstNode );

    //  Parse left value
    if ( NodeIterator_hasNonWhitespace( it ) )
    {
        //  Parse prefix
        const Node*  next  = NodeIterator_next( it );
        const Token* token = Node_getToken( next );
        const char*  value = Token_getContent( first );

        switch ( Token_getTokenType( token ) )
        {
        case PREFIXOP:
            self->prefixOperator = String_new( value );
            break;

        case INSTANCEMEMBER:
        case CLASSMEMBER:
            self->prefixOperator = String_new( value );
            break;

        case INFIXOP:
            self->invalid = TRUE;
            break;

        case POSTFIXOP:
            self->invalid = TRUE;
            break;

        case WORD:
            self->value = String_new( value );
            break;

        default:
            self->invalid = TRUE;
        }

        if ( !self->invalid && !self->value && NodeIterator_hasNonWhitespace( it ) )
        {
            const Node*  secondNode = NodeIterator_next( it );
            const Token* second     = Node_getToken( secondNode );

            switch ( Token_getTokenType( second ) )
            {
            case WORD:
                self->value = String_new( value );
                break;

            default:
                self->invalid = TRUE;
            }

            if ( !self->invalid && self->value && NodeIterator_hasNonWhitespace( it ) )
            {
                const Node*  secondNode = NodeIterator_next( it );
                const Token* second     = Node_getToken( secondNode );

                switch ( Token_getTokenType( second ) )
                {
                case PREFIXOP:
                    self->invalid = TRUE;
                    break;

                case POSTFIXOP:
                    self->postfixOperator = String_new( value );
                    break;

                case INFIXOP:

                    self->infixOperator = String_new( value );
                    IxSourceExpression_parse
                    break;

                }

        //  Parse value
        if ( !self->value && NodeIterator_hasNonWhitespace( it ) )
        {
            const Node*  secondNode = NodeIterator_next( it );
            const Token* second     = Node_getToken( secondNode );

            switch ( Token_getTokenType( second ) )
            {
            case PREFIXOP:
            case POSTFIXOP:
                self->invalid = TRUE;
                break;

            case INFIXOP:
                self->infixOperator = String_new( value );
                break;

            case WORD:
                self->value = String_new( value );
                break;
            
            default:
                self->invalid = TRUE;
            }

            if ( NodeIterator_hasNonWhitespace( it ) )
            {
                const Node*  thirdNode = NodeIterator_next( it );
                const Token* third     = Node_getToken( thirdNode );

                switch ( Token_getTokenType( third ) )
                {
                case PREFIXOP:
                case INFIXOP:
                    self->invalid = TRUE;
                    break;

                case POSTFIXOP:
                    self->postfixOperator = String_new( value );
                    break;

                case WORD:
                    self->value = String_new( value );
                    break;
                
                default:
                    self->invalid = TRUE;
                }
            }
        }
    }
    NodeIterator_free( _it );
}
~



