
.. Ix Source Member

~!include/ixcompiler.IxSourceMember.h~
#ifndef IXCOMPILER_IXSOURCEMEMBER_H
#define IXCOMPILER_IXSOURCEMEMBER_H

#include "ixcompiler.h"

IxSourceMember* IxSourceMember_new( const Node* prefixNode );

IxSourceMember*     IxSourceMember_free(                  IxSourceMember** self );
bool                IxSourceMember_isInvalid      ( const IxSourceMember*  self );
bool                IxSourceMember_isInstance     ( const IxSourceMember*  self );
const String*       IxSourceMember_getName        ( const IxSourceMember*  self );
const IxSourceType* IxSourceMember_getType        ( const IxSourceMember*  self );
const String*       IxSourceMember_getDefaultValue( const IxSourceMember*  self );

#endif
~

~!c/ixcompiler.IxSourceMember.c~
#include "ixcompiler.EnumTokenType.h"
#include "ixcompiler.IxSourceMember.h"
#include "ixcompiler.IxSourceType.h"
#include "ixcompiler.Token.h"

struct _IxSourceMember
{
    bool          invalid;
    bool          isInstance;
    String*       prefix;
    String*       name;
    String*       oftype;
    IxSourceType* type;
    String*       equals;
    String*       defaultValue;
};

static void IxSource_Unit_parseMember( IxSourceMember* self, const Node* prefixNode );
~

~c/ixcompiler.IxSourceMember.c~
IxSourceMember* IxSourceMember_new( const Node* prefixNode )
{
    IxSourceMember* self = Platform_Alloc( sizeof( IxSourceMember ) );
    if ( self )
    {
        self->prefix = String_new( "" );
        self->name   = String_new( "" );
        self->oftype = String_new( "" );
        self->type   = IxSourceType_new( self->oftype );
        self->equals = String_new( "" );
        self->defaultValue = String_new( "" );

        IxSource_Unit_parseMember( self, prefixNode );
    }
    return self;
}
~

~c/ixcompiler.IxSourceMember.c~
IxSourceMember* IxSourceMember_free( IxSourceMember** self )
{
    if ( *self )
    {
        String_free      ( &(*self)->name         );
        IxSourceType_free( &(*self)->type         );
        String_free      ( &(*self)->defaultValue );
        Platform_Free    (    self                );
    }
    return *self;
}
~

~c/ixcompiler.IxSourceMember.c~
bool IxSourceMember_isInvalid( const IxSourceMember* self )
{
    return self->invalid;
}
~

~c/ixcompiler.IxSourceMember.c~
bool IxSourceMember_isInstance( const IxSourceMember* self )
{
    return self->isInstance;
}
~

~c/ixcompiler.IxSourceMember.c~
const String* IxSourceMember_getName( const IxSourceMember* self )
{
    return self->name;
}
~

~c/ixcompiler.IxSourceMember.c~
const IxSourceType* IxSourceMember_getType( const IxSourceMember* self )
{
    return self->type;
}
~

~c/ixcompiler.IxSourceMember.c~
const String* IxSourceMember_getDefaultValue( const IxSourceMember* self )
{
    return self->defaultValue;
}
~

~c/ixcompiler.IxSourceMember.c~
static void IxSource_Unit_parseMember( IxSourceMember* self, const Node* prefixNode )
{
    //  SYMBOL(prefix)
    {
        const Token*  token = Node_getToken     ( prefixNode );
        EnumTokenType type  = Token_getTokenType( token      );
        const char*   value = Token_getContent  ( token      );

        switch ( type )
        {
        case INSTANCEMEMBER:
            self->isInstance = TRUE;
        case CLASSMEMBER:
            self->prefix = String_new( value );
            break;
        
        default:
            self->invalid = TRUE;
        }
    }

    NodeIterator* it = Node_iterator( prefixNode );
    
    //  name
    if ( NodeIterator_hasNonWhitespaceOfType( it, WORD ) )
    {
        String_free( &self->name );
        self->name = String_new( Token_getContent( Node_getToken( NodeIterator_next( it ) ) ) );
    }
    else
    {
        self->invalid = TRUE;
    }

    //  operator
    if ( NodeIterator_hasNonWhitespaceOfType( it, OFTYPE ) )
    {
        String_free( &self->oftype );
        self->oftype = String_new( Token_getContent( Node_getToken( NodeIterator_next( it ) ) ) );
    }
    else
    {
        self->invalid = TRUE;
    }

    //  type
    if
    (
        NodeIterator_hasNonWhitespaceOfType( it, PRIMITIVE )
        ||
        NodeIterator_hasNonWhitespaceOfType( it, WORD )
    )
    {
        const Node*  node  = NodeIterator_next( it );
        const Token* token = Node_getToken( node );

        String* type_name = String_new( Token_getContent( token ) );
        {
            IxSourceType_free( &self->type );
            self->type = IxSourceType_new( type_name );
        }
        String_free( &type_name );

        if ( NodeIterator_hasNonWhitespaceOfType( it, STARTSUBSCRIPT ) )
        {
            NodeIterator_next( it );
            IxSourceType_setAsArray( self->type, TRUE );

            if ( NodeIterator_hasNonWhitespaceOfType( it, ENDSUBSCRIPT ) )
            {
                NodeIterator_next( it );
            }
            else
            {
                self->invalid = TRUE;
            }
        }

        if ( NodeIterator_hasNonWhitespaceOfType( it, INFIXOP ) )
        {
            const Token* token   = Node_getToken( NodeIterator_next( it ) );
            const char*  content = Token_getContent( token );

            switch ( content[0] )
            {
            case '*':
                IxSourceType_setAsPointer( self->type, TRUE );
                break;
            
            case '&':
                IxSourceType_setAsReference( self->type, TRUE );
                break;
            }
        }

        if ( NodeIterator_hasNonWhitespaceOfType( it, ASSIGNMENTOP ) )
        {
            const Token* token = Node_getToken( NodeIterator_next( it ) );
            self->equals = String_new( Token_getContent( token ) );
        }

        if ( NodeIterator_hasNonWhitespace( it ) )
        {
            const Token* token = Node_getToken( NodeIterator_next( it ) );
            self->defaultValue = String_new( Token_getContent( token ) );
        }
    }
}
~
