
.. Ix Source Method

~!include/ixcompiler.IxSourceMethod.h~
#ifndef IXCOMPILER_IXSOURCEMETHOD_H
#define IXCOMPILER_IXSOURCEMETHOD_H

#include "ixcompiler.h"

IxSourceMethod* IxSourceMethod_new( const IxSourceUnit* sourceUnit, const Node* modifierNode );

IxSourceMethod*          IxSourceMethod_free             (       IxSourceMethod** self );
const IxSourceUnit*      IxSourceMethod_getSourceUnit    ( const IxSourceMethod*  self );
const IxSourceSignature* IxSourceMethod_getSignature     ( const IxSourceMethod*  self );
const char*              IxSourceMethod_getAccessModifier( const IxSourceMethod*  self );
const char*              IxSourceMethod_getConst         ( const IxSourceMethod*  self );
const char*              IxSourceMethod_getMethodName    ( const IxSourceMethod*  self );
const Array*             IxSourceMethod_getParameters    ( const IxSourceMethod*  self );
const char*              IxSourceMethod_getReturnType    ( const IxSourceMethod*  self );
const IxSourceBlock*     IxSourceMethod_getMethodBlock   ( const IxSourceMethod*  self );
const Array*             IxSourceMethod_getStatements    ( const IxSourceMethod*  self );

#endif
~

~!c/ixcompiler.IxSourceMethod.c~
#include "ixcompiler.Array.h"
#include "ixcompiler.Console.h"
#include "ixcompiler.EnumTokenType.h"
#include "ixcompiler.IxSourceBlock.h"
#include "ixcompiler.IxSourceMethod.h"
#include "ixcompiler.IxSourceParameter.h"
#include "ixcompiler.IxSourceSignature.h"
#include "ixcompiler.IxSourceType.h"
#include "ixcompiler.IxSourceUnit.h"
#include "ixcompiler.Node.h"
#include "ixcompiler.NodeIterator.h"
#include "ixcompiler.Platform.h"
#include "ixcompiler.String.h"
#include "ixcompiler.Token.h"

struct _IxSourceMethod
{
    bool                      invalid;
    const IxSourceUnit*       sourceUnit;
    IxSourceSignature*        signature;
    IxSourceBlock*            methodBlock;
};

void IxSourceMethod_parseModifier  ( IxSourceMethod* self, const Node* modifierNode   );
void IxSourceMethod_parseMethodName( IxSourceMethod* self, const Node* methodNameNode );
void IxSourceMethod_parseStatements( IxSourceMethod* self, const Node* startBlockNode );
~

~c/ixcompiler.IxSourceMethod.c~
IxSourceMethod* IxSourceMethod_new( const IxSourceUnit* sourceUnit, const Node* modifierNode )
{
    IxSourceMethod* self = Platform_Alloc( sizeof( IxSourceMethod ) );
    if ( self )
    {
        self->sourceUnit = sourceUnit;
        self->signature  = IxSourceSignature_new( sourceUnit, modifierNode );

        IxSourceMethod_parseModifier( self, modifierNode );
    }
    return self;
}
~

~c/ixcompiler.IxSourceMethod.c~
IxSourceMethod* IxSourceMethod_free( IxSourceMethod** self )
{
    if ( *self )
    {
        IxSourceSignature_free( &(*self)->signature   );
        IxSourceBlock_free    ( &(*self)->methodBlock );

        Platform_Free( self );
    }
    return *self;
}
~

~c/ixcompiler.IxSourceMethod.c~
const IxSourceUnit* IxSourceMethod_getSourceUnit( const IxSourceMethod* self )
{
    return self->sourceUnit;
}
~

~c/ixcompiler.IxSourceMethod.c~
const IxSourceSignature* IxSourceMethod_getSignature( const IxSourceMethod* self )
{
    return self->signature;
}
~

~c/ixcompiler.IxSourceMethod.c~
const char* IxSourceMethod_getAccessModifier( const IxSourceMethod* self )
{
    return String_content( IxSourceSignature_getAccessModifier( self->signature ) );
}
~

~c/ixcompiler.IxSourceMethod.c~
const char* IxSourceMethod_getConst( const IxSourceMethod* self )
{
    return String_content( IxSourceSignature_getConst( self->signature ) );
}
~

~c/ixcompiler.IxSourceMethod.c~
const char* IxSourceMethod_getMethodName( const IxSourceMethod* self )
{
    return String_content( IxSourceSignature_getMethodName( self->signature ) );
}
~

~c/ixcompiler.IxSourceMethod.c~
const Array* IxSourceMethod_getParameters( const IxSourceMethod* self )
{
    return IxSourceSignature_getParameters( self->signature );
}
~

~c/ixcompiler.IxSourceMethod.c~
const char* IxSourceMethod_getReturnType( const IxSourceMethod* self )
{
    return String_content( IxSourceType_getName( IxSourceSignature_getReturnType( self->signature ) ) );
}
~

~c/ixcompiler.IxSourceMethod.c~
const IxSourceBlock* IxSourceMethod_getMethodBlock( const IxSourceMethod* self )
{
    return self->methodBlock;
}
~

~c/ixcompiler.IxSourceMethod.c~
const Array* IxSourceMethod_getStatements( const IxSourceMethod* self )
{
    return (self->methodBlock) ? IxSourceBlock_getStatements( self->methodBlock ) : null;
}
~

~c/ixcompiler.IxSourceMethod.c~
void IxSourceMethod_parseModifier( IxSourceMethod* self, const Node* modifierNode )
{
    const Token* token = Node_getToken( modifierNode );
    
    if ( MODIFIER != Token_getTokenType( token ) )
    {
        self->invalid = TRUE;
    }

    NodeIterator* it = Node_iterator( modifierNode );

    //  const (optional)
    if ( NodeIterator_hasNonWhitespaceOfType( it, KEYWORD ) )
    {
        const Node*  node  = NodeIterator_next( it );
        const Token* token = Node_getToken( node );

        if ( ! String_Equals( "const", Token_getContent( token ) ) )
        {
            self->invalid = TRUE;
        }
    }

    //  name
    if ( !NodeIterator_hasNonWhitespaceOfType( it, WORD ) )
    {
        self->invalid = TRUE;
    }
    else
    {
        const Node* next = NodeIterator_next( it );
        IxSourceMethod_parseMethodName( self, next );
    }
}
~

~c/ixcompiler.IxSourceMethod.c~
void IxSourceMethod_parseMethodName( IxSourceMethod* self, const Node* methodNameNode )
{
    NodeIterator* it = Node_iterator( methodNameNode );

    //  (   (startexpression)
    if ( NodeIterator_hasNonWhitespaceOfType( it, STARTEXPRESSION ) )
    {
        NodeIterator_next( it );

        if ( NodeIterator_hasNonWhitespaceOfType( it, OFTYPE ) )
        {
            NodeIterator_next( it );

            if ( NodeIterator_hasNonWhitespaceOfType( it, PRIMITIVE ) || NodeIterator_hasNonWhitespaceOfType( it, WORD ) )
            {
                NodeIterator_next( it );
            }
            else
            {
                self->invalid = TRUE;
            }
        }
        else
        {
            self->invalid = TRUE;
        }

        if ( NodeIterator_hasNonWhitespaceOfType( it, STARTBLOCK ) )
        {
            const Node* next = NodeIterator_next( it );

            self->methodBlock = IxSourceBlock_new( next );
        }
        else
        {
            self->invalid = TRUE;
        }
    }
    else
    {
        self->invalid = TRUE;
    }
}
~
