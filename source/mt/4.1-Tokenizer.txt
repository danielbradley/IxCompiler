
.. Tokenizer

~!include/ixcompiler.Tokenizer.h~
#ifndef IXCOMPILER_TOKENIZER_H
#define IXCOMPILER_TOKENIZER_H

#include "ix.h"
#include "ixcompiler.h"
#include "ixcompiler.EnumTokenType.h"
#include "ixcompiler.EnumTokenGroup.h"

Tokenizer* Tokenizer_new          ( File**      file );

Tokenizer*     Tokenizer_free          (       Tokenizer** self );
Token*         Tokenizer_nextToken     (       Tokenizer*  self );
const Token*   Tokenizer_peekToken     (       Tokenizer*  self );
EnumTokenGroup Tokenizer_peekTokenGroup(       Tokenizer*  self );
EnumTokenType  Tokenizer_peekTokenType (       Tokenizer*  self );
void           Tokenizer_printAll      (       Tokenizer*  self );
bool           Tokenizer_hasMoreTokens ( const Tokenizer*  self );
const File*    Tokenizer_getFile       ( const Tokenizer*  self );

#endif
~


~!c/ixcompiler.Tokenizer.c~
#include "ixcompiler.Token.h"
#include "ixcompiler.TokenGroup.h"
#include "ixcompiler.Tokenizer.h"

struct _Tokenizer
{
    EnumTokenType   lastType;
    bool            ignoreUntilNewline;
    File*           file;
    PushbackReader* reader;
    Queue*          queue;
};

static void primeQueue( Tokenizer* self );
static Token*     next( Tokenizer* self );
~

~c/ixcompiler.Tokenizer.c~
Tokenizer* Tokenizer_new( File** file )
{
    Tokenizer* self = Platform_Alloc( sizeof( Tokenizer ) );

    if ( self )
    {
        self->file   = *file; *file = null;
        self->reader = PushbackReader_new( File_getFilePath( self->file ) );
        self->queue  = Queue_new( (Destructor) Token_free );

        primeQueue( self );
    }
    return self;
}
~

~c/ixcompiler.Tokenizer.c~
Tokenizer* Tokenizer_free( Tokenizer** self )
{
    if ( *self )
    {
        if ( 1 )
        {
            Token* tmp;

            while ( (tmp = Queue_removeHead( (*self)->queue )) )
            {
                Token_free( &tmp );
            }
        }

        File_free          ( &(*self)->file   );
        PushbackReader_free( &(*self)->reader );
        Queue_free         ( &(*self)->queue  );

        Platform_Free( self );
    }
    return *self;
}
~

~c/ixcompiler.Tokenizer.c~
Token* Tokenizer_nextToken( Tokenizer* self )
{
    primeQueue( self );

    if ( Queue_getLength( self->queue ) > 0 )
    {
        return (Token*) Queue_removeHead( self->queue );
    }
    else
    {
        return null;
    }
}
~

~c/ixcompiler.Tokenizer.c~
const Token* Tokenizer_peekToken( Tokenizer* self )
{
    primeQueue( self );

    if ( Queue_getLength( self->queue ) > 0 )
    {
        return (const Token*) Queue_getHead( self->queue );
    }
    else
    {
        return null;
    }
}
~

~c/ixcompiler.Tokenizer.c~
EnumTokenGroup Tokenizer_peekTokenGroup( Tokenizer* self )
{
    const Token* token = Tokenizer_peekToken( self );
    if ( !token )
    {
        return GROUPEND;
    }
    else
    {
        return TokenGroup_getGroupType( Token_getTokenGroup( token ) );
    }
}
~

~c/ixcompiler.Tokenizer.c~
EnumTokenType Tokenizer_peekTokenType( Tokenizer* self )
{
    const Token* token = Tokenizer_peekToken( self );
    if ( !token )
    {
        return END;
    }
    else
    {
        return Token_getTokenType( token );
    }
}
~

~c/ixcompiler.Tokenizer.c~
#include <stdio.h>
void Tokenizer_printAll( Tokenizer* self )
{
    while( Tokenizer_hasMoreTokens( self ) )
    {
        Token* token = Tokenizer_nextToken( self );
        Token_print( token, stdout );
        fprintf( stdout, "\n" );
        Token_free( &token );
    }
}
~

~c/ixcompiler.Tokenizer.c~
bool Tokenizer_hasMoreTokens( const Tokenizer* self )
{
    return (Queue_getLength( self->queue ) > 0);
}
~

~c/ixcompiler.Tokenizer.c~
const File* Tokenizer_getFile( const Tokenizer* self )
{
    return self->file;
}
~

~c/ixcompiler.Tokenizer.c~
static void addTokenToTail( Tokenizer* self, Token** token )
{
    EnumTokenGroup group = Token_getGroupType( *token );
    EnumTokenType  type  = Token_getTokenType( *token );

    switch ( group )
    {
    case WHITESPACE:
    case COMMENT:
        break;
    default:
        self->lastType = type;
    }

    //  Disable STOP prediction in primeQueue
    //  if processing a copyright or license line
    //  until a newline is encountered.
    switch ( type )
    {
    case COPYRIGHT:
    case LICENSE:
        self->ignoreUntilNewline = TRUE;
        break;
    case NEWLINE:
        self->ignoreUntilNewline = FALSE;
        break;
    }

    Queue_addTail( self->queue, (void**) token );
}

static void primeQueue( Tokenizer* self )
{
    Token* token = null;

    if ( (token = next( self )) )
    {
        if ( !self->ignoreUntilNewline )
        {
            if ( Token_ShouldInsertStop( self->lastType, Token_getTokenType( token ) ) )
            {
                addTokenToTail( self, (Token**) Give( Token_CreateStopToken( self ) ) );
            }
        }
        addTokenToTail( self, &token );
    }
}
~

~c/ixcompiler.Tokenizer.c~
static Token* next( Tokenizer* self )
{
    Token* token = null;
    int    ch    = 0;
    int    ch2   = 0;

    if ( (ch = PushbackReader_read( self->reader )) )
    {
        StringBuffer*  sb         = StringBuffer_new();
        TokenGroup*    group      = TokenGroup_new( ch );
        EnumTokenType  token_type = END;
        EnumTokenGroup group_type = TokenGroup_getGroupType( group );

        sb = StringBuffer_append_char( sb, ch );

        while ( (ch2 = PushbackReader_read( self->reader )) )
        {
            if ( ESCAPE == group_type )
            {
                sb  = StringBuffer_append_char( sb, ch2 );
                ch2 = PushbackReader_read( self->reader );
                break;
            }
            else
            if ( (SYMBOLIC == group_type) && ('/' == ch) && ('/' == ch2) )
            {
                sb = StringBuffer_append_char( sb, ch2 );

                while( (ch2 = PushbackReader_read( self->reader )) )
                {
                    if ( '\n' != ch2 )
                    {
                        sb = StringBuffer_append_char( sb, ch2 );
                    }
                    else goto end;
                }
            }
            else
            if ( (SYMBOLIC == group_type) && ('#' == ch) )
            {
                sb = StringBuffer_append_char( sb, ch2 );

                while( (ch2 = PushbackReader_read( self->reader )) )
                {
                    if ( '\n' != ch2 )
                    {
                        sb = StringBuffer_append_char( sb, ch2 );
                    }
                    else goto end;
                }
            }
            else
            if ( (SYMBOLIC == group_type) && ('/' == ch) && ('*' == ch2) )
            {
                sb = StringBuffer_append_char( sb, ch2 );

                while( (ch2 = PushbackReader_read( self->reader )) )
                {
                    sb = StringBuffer_append_char( sb, ch2 );

                    if ( '*' == ch2 )
                    {
                        ch2 = PushbackReader_read( self->reader );
                        sb = StringBuffer_append_char( sb, ch2 );

                        if ( '/' == ch2 )
                        {
                            ch2 = 0;
                            goto end;
                        }
                    }
                }
            }
            else
            if ( TokenGroup_matches( group, ch2 ) )
            {
                if ( '\\' == ch2 )
                {
                    sb  = StringBuffer_append_char( sb, ch2 );
                    ch2 = PushbackReader_read( self->reader );
                    sb  = StringBuffer_append_char( sb, ch2 );
                }
                else
                {
                    sb  = StringBuffer_append_char( sb, ch2 );
                }
            }
            else
            if ( STRING == group_type )
            {
                sb = StringBuffer_append_char( sb, ch2 );
                ch2 = PushbackReader_read( self->reader );
                break;
            }
            else
            if ( CHAR == group_type )
            {
                sb = StringBuffer_append_char( sb, ch2 );
                ch2 = PushbackReader_read( self->reader );
                break;
            }
            else
            {
                break;
            }
        }
end:

        if ( ch2 )
        {
            PushbackReader_pushback( self->reader );
        }

        if ( !StringBuffer_isEmpty( sb ) )
        {
            token = Token_new( self, StringBuffer_content( sb ), group );
        }

        StringBuffer_free( &sb );
        TokenGroup_free( &group );
    }
    return token;
}
~
