
. Implementation

~
ixc --output-dir _gen/c --target-language C [--dry-run]
~

~!c/main.c~
//
//  Copyright 2021 Daniel Robert Bradley
//

#include <stdlib.h>
#include <stdio.h>

#include "ixcompiler.h"
#include "ixcompiler.Arguments.h"
#include "ixcompiler.AST.h"
#include "ixcompiler.ASTCollection.h"
#include "ixcompiler.ASTPrinter.h"
#include "ixcompiler.Generator.h"
#include "ixcompiler.IxParser.h"
#include "ixcompiler.IxSourceUnit.h"
#include "ixcompiler.IxSourceUnitCollection.h"
#include "ixcompiler.Token.h"
#include "ixcompiler.Tokenizer.h"
#include "todo.h"

int main( int argc, char** argv )
{
    int            status      = 1;
    Arguments*     args        = Arguments_new          ( argc, argv );
    bool           dry_run     = Arguments_hasFlag      ( args, ARGUMENT_DRY_RUN );
    const char*    target_lang = Arguments_getOption    ( args, ARGUMENT_TARGET_LANGUAGE );
    const char*    output_dir  = Arguments_getOption    ( args, ARGUMENT_OUTPUT_DIR );
    FilesIterator* files       = Arguments_filesIterator( args );
    Path*          output_path = Path_new               ( output_dir );
    GeneratorFn    generator   = Generator_FunctionFor  ( target_lang );


    if ( !Arguments_hasFlag( args, ARGUMENT_OUTPUT_DIR ) )
    {
        Console_Write( ABORT_NO_OUTPUT_DIR, "" );
        exit( -1 );
    }
    else
    if ( !Arguments_hasFlag( args, ARGUMENT_TARGET_LANGUAGE ) )
    {
        Console_Write( ABORT_TARGET_LANGUAGE_NOT_SPECIFIED, "" );
        exit( -1 );
    }
    else
    if ( !Path_exists( output_path ) )
    {
        Console_Write( ABORT_DIRECTORY_DOES_NOT_EXIST, output_dir );
        exit( -1 );
    }
    else
    if ( !Path_canWrite( output_path ) )
    {
        Console_Write( ABORT_DIRECTORY_IS_NOT_WRITABLE, output_dir );
        exit( -1 );
    }
    else
    if ( !generator )
    {
        Console_Write( ABORT_TARGET_LANGUAGE_NOT_SUPPORTED, target_lang );
        exit( -1 );
    }
    else
    if ( !FilesIterator_hasNext( files ) )
    {
        Console_Write( ABORT_NO_SOURCE_FILES, "" );
        exit( -1 );
    }
    else
    {
        ASTCollection*          ast_collection = ASTCollection_new();
        IxSourceUnitCollection* source_units   = IxSourceUnitCollection_new();

        while ( FilesIterator_hasNext( files ) )
        {
            File* file = FilesIterator_next( files );

            if ( !File_exists( file ) )
            {
                Console_Write( ABORT_FILE_DOES_NOT_EXIST, File_getFilePath( file ) );
                exit( -1 );
            }
            else
            if ( !File_canRead( file ) )
            {
                Console_Write( ABORT_FILE_CANNOT_BE_READ, File_getFilePath( file ) );
                exit( -1 );
            }
            else
            {
                Tokenizer* t = Tokenizer_new( &file );
                if ( FALSE )
                {
                    Tokenizer_printAll( t );
                    Tokenizer_free( &t );
                }
                else
                {
                    AST* ast = AST_new( &t );
                    ASTPrinter_Print( ast );
                    ASTCollection_add( ast_collection, &ast );
                }
            }
        }

        int n = ASTCollection_getLength( ast_collection );

        for ( int i=0; i < n; i++ )
        {
            const AST* ast = ASTCollection_get( ast_collection, i );

            IxSourceUnit* source_unit = IxSourceUnit_new( ast );

            IxSourceUnitCollection_add( source_units, &source_unit );
        }

        if ( FALSE )//!dry_run )
        {

            if ( generator )
            {
                status = generator( source_units, output_path );
            }
        }

        ASTCollection_free         ( &ast_collection );
        IxSourceUnitCollection_free( &source_units   );
    }

    Arguments_free    ( &args        );
    FilesIterator_free( &files       );
    Path_free         ( &output_path );

    return !status;
}
~
